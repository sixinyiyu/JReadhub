## 消息保证幂等性

>幂等性：就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 比如用户订单付款，点击户口后由于网络等原因，导致用户未看到付款成功提示但是后端实际可以发生了扣款，当用户再次付款那同一订单就会扣款2次，多扣了用户的钱，这就不幂等了。

:collision: 简单粗暴的理解，保证消息幂等性就是不重复消费

* 在一定有效时限内，将已经消费的消息ID存储起来(内存中或Redis中)，每次消费时需要做一次判断

* 对消息的业务承载数据，利用数据库的约束对业务做唯一校验，或者用状态码的流转验证(如订单：大概有 创建、未支付、已支付、已取消、已过期  它们有前后或者互斥)，数据库操作成功后才算未重复消费

* 对于前端提交的请求，可以每次提交的时候根据业务参数以及其他标识变量等生成一个requestId，此requestId是一次性的，用过就作废，后端对requestId的可用性做验证


## 消息如何不丢失

> 消息不丢失，其实就是说要保证消息的可靠性，起码的99.99%啊

看看消息的流程
![MQ流程](http://wx4.sinaimg.cn/large/9c349f47gy1fy1hgt7r7pj20oz05hglk.jpg)

消息丢失可能会存在下面几个地方

1. 生产者生产消息后发送到MQ失败

> 生产者这边失败，如果自己生产消息失败，这个是自己系统不稳健(系统自己做补偿 启动任务定时查看哪些需要重发)，那就只能是在发送到MQ的时候失败了，生产者未做相应处理；一般在生产中我们会开启MQ的消息确认机制，生产者发送消息后，MQ成功接收到消息就会通知生产者说消息我已经成功接收到了，如果生产者超过一定时间还未收到确认，就把此条消息标记为发送失败，后续定时在重发。

2. MQ中心存储消息失败

> MQ存储消息失败，这个一般是消息存储在内存中，机器挂了或者重启了就会把那部分未来得及处理的消息就丢失了，就需要开启MQ的消息持久化，将消息落地到磁盘中

3. 消费者消费MQ的过程中失败,但是MQ中心误以为成功并删除了消息

> 这种情况是，消费者从MQ中心开始消费消息，但是在处理的过程中出错了(bug、重启或者宕机了)那么就是说这条消息的业务没有处理成功，但是MQ中心看到消费者消费了这个消息就认为成功了就会默认吧消息删除了，这时我们也需要开启消费者消息消息的确认模式,只有消费者在消费成功后，发送通知告知MQ中心这条消息已经成功处理了，这个时候才会删除。

#### 一种消息可靠投递的方案思路

![一种消息可靠投递的方案思路](http://wx4.sinaimg.cn/large/9c349f47gy1fz47c25dvoj20mt0evwfp.jpg)


## 消息挤压怎么处理

> 消息挤压，举例的话生产者生产消息非常牛逼，卡卡卡的一顿发送了非常多的消息到MQ，但是由于消费者消费能力非常弱鸡或者消费者挂了，这个时候入远远大于出，就会出现在MQ挤压了大量的消息。消息挤压多了首先，后面的业务处理不过来这是一个问题，两位消息中心存储容量不够就会造成后续消息写入不了消息中心进而影响整个业务系统。

:exclamation: 摘取下网上学习到的方案： 第一步首先找到挤压消息对应的消费者系统，然后马上针对消费消息的处理逻辑做一个新的应用，专门处理消费消息；第二步将原有消费者系统调整下，将消费的消息直接写入另外一个队列中，而不进行业务处理，第一步的新应用直接监听新的消息队列产生的消息，并且水平扩容尽量多的机器消费。待后续消费挤压的消息后在改回来等。

## 消息消费如何保证顺序性

> 消息生产者发送多条消息，如果这几条消息是有先后逻辑的话，就需要保证消费的时候也是有先后的问题，否则可能会影响业务，但是一般大部分情况下消息都是顺序无关的。


消息顺序的示例： 用户支付后，送积分；支付中心会产生orderId 支付状态为已支付，memberId 累加积分关联业务ID是orderId的两条消息； 其中积分系统在处理积分消息的时候，肯定还是要去校验一下参数，看看这个订单是否已经支付，是否是此用户的； 所以应该要在订单处理消息后才处理这个送积分的逻辑

首先要清楚消息中心是顺序

* 我们不能保证全局的消息顺序，但是可以保证局部消息有序(同一队列或者同一分区)


## 消息队列如何保证高可用性

## 如何自己设计实现一个消息队列